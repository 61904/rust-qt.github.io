<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ritual</title><link>https://rust-qt.github.io/</link><description>Recent content on Ritual</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 21 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://rust-qt.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Setting up</title><link>https://rust-qt.github.io/processing_cpp_library/setting_up/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/processing_cpp_library/setting_up/</guid><description>Using docker (recommended) To make sure the parsing results are consistent and reproducible, it&amp;rsquo;s recommended to use a reproducible environment, such as provided by docker. This will also help your future contributors.
Ritual provides a Dockerfile containing its dependencies. This image is published at riateche/ritual_builder. If the published version isn&amp;rsquo;t suitable, you can build the image locally:
cd ritual docker build . -f docker.builder.dockerfile -t riateche/ritual_builder Use this image as a base and create your own image that installs and sets up the C++ library you want to work with.</description></item><item><title>Setting up</title><link>https://rust-qt.github.io/qt/setting_up/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/qt/setting_up/</guid><description>In addition to Rust&amp;rsquo;s own build tools, you&amp;rsquo;ll need to set up a C++ compiler, Qt, and CMake.
C++ compiler On Linux, install gcc from the repository.
On Windows, install Visual Studio (e.g. Visual Studio Community 2017). Make sure to enable the component for C++ application development when installing Visual Studio.
Visual Studio will create a starting menu option (e.g. x64 Native Tools Command Prompt for VS 2017) for starting command prompt with environment variables set up.</description></item><item><title>Setting up</title><link>https://rust-qt.github.io/ritual/setting_up/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/ritual/setting_up/</guid><description>Using docker (recommended) To make sure the parsing results are consistent and reproducible, it&amp;rsquo;s recommended to use a reproducible environment, such as provided by docker.
Ritual provides Dockerfiles containing its dependencies:
docker.builder.dockerfile is the base image suitable for working on C++'s standard library. It also should be used as a base image when working on other C++ libraries. docker.qt.dockerfile is the image used for generating Qt crates. You can build the images with these commands:</description></item><item><title>Getting started</title><link>https://rust-qt.github.io/qt/getting_started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/qt/getting_started/</guid><description>To use Qt from Rust, add the crates as dependencies to your Cargo.toml, for example:
[dependencies] qt_widgets = &amp;#34;0.5&amp;#34; Each crate re-exports its dependencies, so, for example, you can access qt_core as qt_widgets::qt_core without adding an explicit dependency. You can also add them as direct dependencies for convenience, but make sure to use compatible versions.
See rust-qt/examples repository to see how to use the API provided by Qt crates.
Most of the Qt API is translated to Rust as-is when possible.</description></item><item><title>Running generator</title><link>https://rust-qt.github.io/processing_cpp_library/running_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/processing_cpp_library/running_generator/</guid><description>Creating the generator Create a new binary Rust crate and add ritual as a dependency. In the main function, you need to construct a ritual::config::GlobalConfig and pass it to ritual::cli::run_from_args. GlobalConfig allows you to process multiple libraries (or parts of a library as separate crates) in a single run, but in the simple case it just contains a function that creates a Config for your library.
Config is the main way of configuring ritual.</description></item><item><title>Running generator</title><link>https://rust-qt.github.io/ritual/running_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/ritual/running_generator/</guid><description>Note: as described above, it&amp;rsquo;s recommended to use docker for creating a suitable environment.
The generator itself (ritual) is a library which exposes API for configurating different aspects of the process. In order to run the generator and produce an output crate, one must use a binary crate (such as qt_ritual) and launch the generator using its API.
Qt crates can be generated like this:
cd ritual cargo run --release --bin qt_ritual -- /path/to/workspace -c qt_core -o main The workspace directory will be used for storing databases, temporary files, and the generated crates.</description></item><item><title>Smart pointers</title><link>https://rust-qt.github.io/qt/smart_pointers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/qt/smart_pointers/</guid><description>Smart pointers are provided by the cpp_core crate to make working with C++ objects from Rust easier:
CppBox: owned, non-null (corresponds to C++ objects passed by value or pointers that semantically own the object) Ptr: possibly owned, possibly null (correspond to C++ pointers) Ref: not owned, non-null (correspond to C++ references) Unlike Rust references, these pointers can be freely copied, producing multiple mutable pointers to the same object, which is usually necessary to do when working with C++ libraries.</description></item><item><title>Unsafety</title><link>https://rust-qt.github.io/qt/unsafety/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/qt/unsafety/</guid><description>It&amp;rsquo;s impossible to bring Rust&amp;rsquo;s safety to C++ APIs automatically, so most of the generated APIs are unsafe to use and require thinking in C++ terms. Most of the generated functions are unsafe because raw pointers are not guaranteed to be valid, and most functions dereference some pointers.
It&amp;rsquo;s recommended to contain unsafe usage in a module and implement a safe interface for the parts of API required for your project.</description></item><item><title>Deployment</title><link>https://rust-qt.github.io/qt/deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/qt/deployment/</guid><description>All (or most) builds of Qt available in the official installer, Linux repositories, and brew are shared libraries or frameworks. This means that any executable built with these libraries will depend on Qt and won&amp;rsquo;t run if Qt is not present on the end user&amp;rsquo;s system.
It&amp;rsquo;s possible to build Qt statically, so that you can build a standalone executable, but it&amp;rsquo;s a more complicated process. Removing dependency on vc-redist dynamic library on Windows is also hard to do.</description></item><item><title>Qt crates release 0.5</title><link>https://rust-qt.github.io/blog/qt_crates_release_0_5/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/blog/qt_crates_release_0_5/</guid><description>&lt;p>Qt crates (&lt;code>qt_core&lt;/code>, &lt;code>qt_gui&lt;/code>, &lt;code>qt_widgets&lt;/code>, &lt;code>qt_ui_tools&lt;/code>, &lt;code>qt_3d_core&lt;/code>, &lt;code>qt_3d_render&lt;/code>, &lt;code>qt_3d_input&lt;/code>, &lt;code>qt_3d_logic&lt;/code>, &lt;code>qt_3d_extras&lt;/code>, &lt;code>qt_charts&lt;/code>, &lt;code>qt_qml&lt;/code>) provide unsafe API to &lt;a href="https://www.qt.io/">Qt&lt;/a> for Rust applications. Qt is a cross-platform framework for creating GUIs and applications. See &lt;a href="https://rust-qt.github.io/qt/">Rust + Qt guide&lt;/a> for a step-by-step introduction and &lt;a href="https://github.com/rust-qt/examples">rust-qt/examples&lt;/a> repository for code examples.&lt;/p>
&lt;p>New features:&lt;/p></description></item></channel></rss>