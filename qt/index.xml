<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust + Qt guide on Ritual</title><link>https://rust-qt.github.io/qt/</link><description>Recent content in Rust + Qt guide on Ritual</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://rust-qt.github.io/qt/index.xml" rel="self" type="application/rss+xml"/><item><title>Setting up</title><link>https://rust-qt.github.io/qt/setting_up/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/qt/setting_up/</guid><description>In addition to Rust&amp;rsquo;s own build tools, you&amp;rsquo;ll need to set up a C++ compiler, Qt, and CMake.
C++ compiler On Linux, install gcc from the repository.
On Windows, install Visual Studio (e.g. Visual Studio Community 2017). Make sure to enable the component for C++ application development when installing Visual Studio.
Visual Studio will create a starting menu option (e.g. x64 Native Tools Command Prompt for VS 2017) for starting command prompt with environment variables set up.</description></item><item><title>Getting started</title><link>https://rust-qt.github.io/qt/getting_started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/qt/getting_started/</guid><description>To use Qt from Rust, add the crates as dependencies to your Cargo.toml, for example:
[dependencies] qt_widgets = &amp;#34;0.2&amp;#34; Each crate re-exports its dependencies, so, for example, you can access qt_core as qt_widgets::qt_core without adding an explicit dependency.
You can look at the examples in this repository to see how to use the API.
Most of the Qt API is translated to Rust as-is (only modified according to Rust&amp;rsquo;s identifier naming convention), so you can address the Qt documentation for information on it.</description></item><item><title>Smart pointers</title><link>https://rust-qt.github.io/qt/smart_pointers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/qt/smart_pointers/</guid><description>Smart pointers are provided by the cpp_core crate to make working with C++ objects from Rust easier:
CppBox: owned, non-null (corresponds to C++ objects passed by value) Ptr and MutPtr: possibly owned, possibly null (correspond to C++ pointers) Ref and MutRef: not owned, non-null (correspond to C++ references) Unlike Rust references, these pointers can be freely copied, producing multiple mutable pointers to the same object, which is usually necessary to do when working with C++ libraries.</description></item><item><title>Unsafety</title><link>https://rust-qt.github.io/qt/unsafety/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/qt/unsafety/</guid><description>It&amp;rsquo;s impossible to bring Rust&amp;rsquo;s safety to C++ APIs automatically, so most of the generated APIs are unsafe to use and require thinking in C++ terms. Most of the generated functions are unsafe because raw pointers are not guaranteed to be valid, and most functions dereference some pointers.
It&amp;rsquo;s recommended to contain unsafe usage in a module and implement a safe interface for the parts of API required for your project.</description></item><item><title>Deployment</title><link>https://rust-qt.github.io/qt/deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-qt.github.io/qt/deployment/</guid><description>All (or most) builds of Qt available in the official installer, Linux repositories, and brew are shared libraries or frameworks. This means that any executable built with these libraries will depend on Qt and won&amp;rsquo;t run if Qt is not present on the end user&amp;rsquo;s system.
It&amp;rsquo;s possible to build Qt statically, so that you can build a standalone executable, but it&amp;rsquo;s a more complicated process. Removing dependency on vc-redist dynamic library on Windows is also hard to do.</description></item></channel></rss>