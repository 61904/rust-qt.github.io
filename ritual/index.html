<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>About Ritual - Ritual</title><meta name=description content="Use C++ libraries from Rust"><meta name=generator content="Hugo 0.66.0"><link href=https://rust-qt.github.io/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://rust-qt.github.io/ritual/><link rel=stylesheet href=https://rust-qt.github.io/css/theme.min.css><link type=text/css rel=stylesheet href=https://rust-qt.github.io/syntax.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://rust-qt.github.io/css/chroma.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://rust-qt.github.io/js/bundle.js></script><style>:root{}</style><meta property="og:title" content="About Ritual"><meta property="og:description" content="Use C++ libraries from Rust"><meta property="og:type" content="website"><meta property="og:url" content="https://rust-qt.github.io/ritual/"><meta property="og:image" content="https://rust-qt.github.io/images/og-image.png"><meta property="og:site_name" content="Ritual"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rust-qt.github.io/images/og-image.png"><meta name=twitter:title content="About Ritual"><meta name=twitter:description content="Use C++ libraries from Rust"><meta itemprop=name content="About Ritual"><meta itemprop=description content="Use C++ libraries from Rust"><link rel=alternate type=application/rss+xml href=https://rust-qt.github.io/ritual/index.xml title=Ritual></head><body><div class=container><header><h1><a href=/>Ritual</a></h1><a href=https://github.com/rust-qt/ritual class=github><i class="fab fa-github"></i></a><p class=description>Use C++ libraries from Rust</p></header><div class=global-menu><nav><ul><li><a href=/ritual/>About Ritual</a></li><li><a href=/qt/>Rust + Qt guide</a></li><li><a href=/blog/>Blog</a></li></ul></nav></div><div class=content-container><main><h1>About Ritual</h1><h2 id=crust-features-coverage>C++/Rust features coverage</h2><p>Supported features:</p><ul><li>Primitive types are mapped to Rust&rsquo;s primitive types (like <code>bool</code>) and FFI types (like <code>c_int</code>).</li><li>Fixed-size numeric types (e.g <code>int8_t</code> or <code>qint8</code>) are mapped to Rust&rsquo;s fixed size types (e.g. <code>i8</code>).</li><li>Pointers, references and values are mapped to special smart pointer types (<code>Ref</code>, <code>Ptr</code>, <code>CppBox</code>, etc.) provided by the <code>cpp_core</code> crate.</li><li>C++ namespaces are mapped to Rust modules.</li><li>C++ classes, structs, and enums are mapped to Rust structs. This also applies to all instantiations of template classes encountered in the library&rsquo;s API, including template classes of dependencies.</li><li>Free functions are mapped to free functions.</li><li>Class methods are mapped to structs&rsquo; implementations.</li><li>Destructors are mapped to <code>CppDeletable</code> implementations and can be automatically invoked by <code>CppBox</code>.</li><li>Function pointer types are mapped to Rust&rsquo;s equivalent representation. Function pointers with references or class values are not supported.</li><li><code>static_cast</code> and <code>dynamic_cast</code> are available in Rust through corresponding traits.</li><li>Methods inherited from base classes are available via <code>Deref</code> implementation (if the class has multiple bases, only the first base&rsquo;s methods are directly available).</li><li>Getter and setter methods are created for each public class field.</li><li>Operators are translated to Rust&rsquo;s operator trait implementations when possible.</li><li>C++ STL-style iterators are accessible from Rust via adaptors.</li></ul><p>Names of Rust identifiers are modified according to Rust&rsquo;s naming conventions.</p><p>Documentation is important! <code>ritual</code> generates <code>rustdoc</code> comments with information about corresponding C++ types and methods. Qt documentation is integrated in <code>rustdoc</code> comments.</p><p>Not implemented yet but can be implemented in the future:</p><ul><li>Translate C++ <code>typedef</code>s to Rust type aliases.</li><li>Implement <code>Debug</code> and <code>Display</code> traits for structs if applicable methods exist on C++ side.</li><li>(<a href=https://github.com/rust-qt/ritual/issues/26>Implement subclassing API</a>).</li></ul><p>Not planned to support:</p><ul><li>Advanced template usage, like types with integer template arguments.</li><li>Template partial specializations.</li></ul><h2 id=qt-specific-features-coverage>Qt-specific features coverage</h2><ul><li><code>QFlags&lt;Enum></code> types are converted to Rust&rsquo;s own similar implementation located at <code>qt_core::QFlags</code>).</li><li><code>qt_core</code> implements a way to use signals and slots. It&rsquo;s possible to use signals and slots of the built-in Qt classes. Rust code can also create slots bound to an arbitrary closure and custom signals. Argument types compatibility is checked at compile time.</li></ul><h2 id=api-stability-and-versioning>API stability and versioning</h2><p>Ritual can analyze multiple different versions of the C++ library and generate a crate that supports all of them. Parts of the API that are common across versions are guaranteed to have the same Rust API as well. For parts of the API that are not always available, the Rust bindings will have feature attributes that only enable them if the current local version of the C++ library has them. Trying to use a feature not available in the installed version of C++ library will result in a compile-time error.</p><p>When a new version of the C++ library is released, ritual can preserve all existing API in the generated crate and add newly introduced API items under a feature flag. This allows to make semver-compatible changes to the generated crate to support all available versions of the C++ library.</p><h2 id=managing-dependencies>Managing dependencies</h2><p>C++, like most languages, allows libraries to use types from other libraries in their public API. When Rust bindings are generated, they should ideally reuse common dependencies instead of producing a copy of wrappers in each crate. Ritual supports exporting types from already processed dependencies and using them in the public API.</p><p>If a ritual-based crate is published on <code>crates.io</code> and you want to use it as a dependency when generating your own bindings, ritual can export the information from it as well. This allows independent developers to base upon each other&rsquo;s work instead of repeating it.</p><p>In addition to Qt crates, ritual project provides the <code>cpp_std</code> crate that provides access to C++'s standard library types. It should be used when processing a library that uses STL types in its API. However, <code>cpp_std</code> is still in early development and only provides access to a small part of the standard library.</p><h2 id=platform-support>Platform support</h2><p>Linux, macOS, and Windows are supported. <code>ritual</code> and Qt crates are <a href=https://travis-ci.com/rust-qt/ritual/branches>continuously tested on Travis</a>.</p><h2 id=safety>Safety</h2><p>It&rsquo;s impossible to bring Rust&rsquo;s safety to C++ APIs automatically, so most of the generated APIs are unsafe to use and require thinking in C++ terms. Most of the generated functions are unsafe because raw pointers are not guaranteed to be valid, and most functions dereference some pointers.</p><p>One of intended uses of ritual is to generate a low level interface and then write a safe interface on top of it (which can only be done manually). For huge libraries like Qt, when it&rsquo;s not feasible to design a safe fully-featured API for the whole library, it&rsquo;s recommended to contain unsafe usage in a module and implement a safe interface for the parts of API required for your project.</p><h2 id=executable-size>Executable size</h2><p>Rust crates and C++ wrapper libraries are built statically by default, and the linker only runs once for the final executable that uses the crates. It should be able to eliminate all unused wrapper functions and produce a reasonably small file that will only depend on original C++ libraries.</p><h2 id=how-it-works>How it works</h2><p>The generator runs in the following steps:</p><ol><li>If the target library has any dependencies which were already processed and converted to Rust crates, information collected during their generation is loaded from the workspace directory or from <code>crates.io</code> and used for further processing.</li><li><code>clang</code> C++ parser is executed to extract information about the library&rsquo;s types and methods from its header files.</li><li>The detected methods are checked to filter out invalid parse results.</li><li>A C++ wrapper library with C-compatible interface is generated. The library exposes each found method using a wrapper function.</li><li>A Rust code for the crate is generated. Functions from the C++ wrapper library are made available in the crate using Rust&rsquo;s <a href=https://doc.rust-lang.org/book/ffi.html>FFI support</a>. Rust code also contains <code>struct</code>s for all found C++ enums, structs and classes (including instantiations of template classes).</li><li>C++ library documentation (if available) and <code>ritual</code>'s processing data are used to generate a full-featured documentation for the crate (<a href=https://rust-qt.github.io/rustdoc/qt/qt_core/index.html>example</a>).</li><li>The Rust code is saved to the output directory along with any extra files (tests, examples, etc.) provided by the caller. A build script necessary for building the crate is also attached.</li><li>Internal information of the generator is written to the database file and can be used when processing the library&rsquo;s dependants.</li></ol><div class=edit-meta><a href=https://github.com/rust-qt/website/edit/master/content/ritual/_index.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=https://rust-qt.github.io/ title=Ritual><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Ritual</a>
<a class="nav nav-next" href=https://rust-qt.github.io/ritual/setting_up/ title="Setting up">Next - Setting up <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=https://rust-qt.github.io/>Home</a></li><li class="parent active"><a href=https://rust-qt.github.io/ritual/>About Ritual</a><ul class=sub-menu><li><a href=https://rust-qt.github.io/ritual/setting_up/>Setting up</a></li><li><a href=https://rust-qt.github.io/ritual/running_generator/>Running generator</a></li></ul></li><li><a href=https://rust-qt.github.io/qt/>Rust + Qt guide</a><ul class=sub-menu><li><a href=https://rust-qt.github.io/qt/setting_up/>Setting up</a></li><li><a href=https://rust-qt.github.io/qt/getting_started/>Getting started</a></li><li><a href=https://rust-qt.github.io/qt/smart_pointers/>Smart pointers</a></li><li><a href=https://rust-qt.github.io/qt/unsafety/>Unsafety</a></li><li><a href=https://rust-qt.github.io/qt/deployment/>Deployment</a></li></ul></li><li><a href=https://rust-qt.github.io/processing_cpp_library/>Processing a C++ library</a><ul class=sub-menu><li><a href=https://rust-qt.github.io/processing_cpp_library/setting_up/>Setting up</a></li><li><a href=https://rust-qt.github.io/processing_cpp_library/running_generator/>Running generator</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>